<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0,viewport-fit=cover"
        />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="mobile-web-app-capable" content="yes" />
        <meta
            name="apple-mobile-web-app-status-bar-style"
            content="black-translucent"
        />
        <meta name="apple-mobile-web-app-title" content="Handmade Hero" />
        <link rel="icon" href="favicon.svg" data-padding="20" />
        <title>Handmade Hero</title>
    </head>
    <body>
        <svg id="handmadeStick" viewBox="-150 -150 300 300" class="stick">
            <circle cx="0" cy="0" r="100" fill="#1115"></circle>
            <circle cx="0" cy="0" r="10" fill="#111a"></circle>
            <circle
                id="handmadeStickNob"
                cx="0"
                cy="0"
                r="50"
                fill="#111a"
            ></circle>
        </svg>
        <div class="app">
            <div class="grid" id="handmadeGrid">
                <canvas id="handmadeCanvas" width="800" height="600"></canvas>
                <svg
                    id="handmadeSvg"
                    viewBox="-150 -150 300 300"
                    class="svg-render"
                >
                    <g id="handmadeSvgInner"></g>
                </svg>
                <div class="grid-inner">
                    <header id="handmadeHeader">
                        <a href="" title="Reload">
                            <h1>
                                <img src="favicon.svg" alt="Icon" />
                                Handmade Hero
                            </h1>
                        </a>
                        <p>
                            Web Version of an
                            <a
                                href="https://guide.handmadehero.org/"
                                target="_blank"
                                >Handmade Hero Style Game</a
                            >
                        </p>
                    </header>

                    <section class="panel">
                        <fieldset>
                            <div class="controls">
                                <label>
                                    <input
                                        type="checkbox"
                                        id="handmadeMute"
                                        checked="checked"
                                    />
                                    Muted
                                </label>
                                <label>
                                    Volume:
                                    <input
                                        type="range"
                                        min="0"
                                        max="1"
                                        step="0.01"
                                        id="handmadeVolume"
                                        value="0.4"
                                    />
                                </label>
                            </div>
                        </fieldset>
                        <details>
                            <summary>Settings</summary>
                            <div class="controls">
                                <label>
                                    <input
                                        type="checkbox"
                                        id="handmadeOptionCanvas"
                                        checked
                                    />
                                    Render Canvas
                                </label>
                                <label>
                                    <input
                                        type="checkbox"
                                        id="handmadeOptionSvg"
                                    />
                                    Render SVG
                                </label>

                                <label>
                                    <input
                                        type="checkbox"
                                        id="handmadeOptionWebGl"
                                    />
                                    Render WebGL
                                </label>
                            </div>
                        </details>
                        <details>
                            <summary>About</summary>
                            <div>
                                <p>
                                    Press <kbd>Right Arrow</kbd> to spawn a new
                                    player.
                                </p>
                                <p>
                                    Press <kbd>W</kbd>, <kbd>A</kbd>,
                                    <kbd>S</kbd>, <kbd>D</kbd> to move around.
                                </p>
                                <p>
                                    Press <kbd>Backspace</kbd> to build a wall
                                    or use the left and right mouse buttons to
                                    draw/erase walls.
                                </p>
                                <p>
                                    Press middle mouse button to pan the camera.
                                    Use the scrollwheel to pan the camera up and
                                    down or hold <kbd>Space bar</kbd> while
                                    scrolling to zoom in and out.
                                </p>
                            </div>
                        </details>

                        <details>
                            <summary>Buttons</summary>
                            <div id="handmadeVirtualButtons">
                                <fieldset>
                                    <label>Mouse</label>
                                    <div class="controls">
                                        <button data-mouse-button="0">
                                            Left
                                        </button>
                                        <button data-mouse-button="1">
                                            Middle
                                        </button>
                                        <button data-mouse-button="2">
                                            Right
                                        </button>
                                        <button data-mouse-button="3">
                                            Extra1
                                        </button>
                                        <button data-mouse-button="4">
                                            Extra2
                                        </button>
                                    </div>
                                </fieldset>
                                <fieldset>
                                    <label>Controller #0</label>
                                    <div class="controls">
                                        <button data-controller-button="0">
                                            MoveUp
                                        </button>
                                        <button data-controller-button="1">
                                            MoveDown
                                        </button>
                                        <button data-controller-button="2">
                                            MoveLeft
                                        </button>
                                        <button data-controller-button="3">
                                            MoveRight
                                        </button>
                                        <button data-controller-button="4">
                                            ActionUp
                                        </button>
                                        <button data-controller-button="5">
                                            ActionDown
                                        </button>
                                        <button data-controller-button="6">
                                            ActionLeft
                                        </button>
                                        <button data-controller-button="7">
                                            ActionRight
                                        </button>
                                        <button data-controller-button="8">
                                            LeftShoulder
                                        </button>
                                        <button data-controller-button="9">
                                            RightShoulder
                                        </button>
                                        <button data-controller-button="10">
                                            Menu
                                        </button>
                                        <button data-controller-button="11">
                                            Back
                                        </button>
                                    </div>
                                </fieldset>
                            </div>
                        </details>

                        <details>
                            <summary>Log</summary>
                            <pre id="handmadeLog"></pre>
                        </details>
                    </section>
                </div>
            </div>

            <script type="module">
                function log(label, ...args) {
                    if (handmadeLog.childNodes.length > 5) {
                        handmadeLog.removeChild(handmadeLog.firstChild);
                    }
                    handmadeLog.appendChild(
                        document.createTextNode(
                            label + ": " + args.join(", ") + "\n",
                        ),
                    );
                }
                const memory = new WebAssembly.Memory({
                    initial: 32,
                    maximum: 32,
                    shared: true,
                });

                const wasm = await WebAssembly.compileStreaming(
                    fetch("handmade.wasm"),
                );
                const instance = await WebAssembly.instantiate(wasm, {
                    env: {
                        memory,
                    },
                });

                handmadeMute.checked = true;

                const renderBase = instance.exports.get_render_list();

                instance.exports.setup();
                instance.exports.controller_button_press(0, 7);
                const audioCtxLazy = (() => {
                    let mem = null;
                    return async (reset) => {
                        if (reset && mem) {
                            const {
                                audioCtx: oldCtx,
                                gain: oldGain,
                                buffer: oldBuffer,
                                volume: oldValume,
                            } = mem;
                            oldGain.disconnect();
                            oldValume.disconnect();
                            oldBuffer.disconnect();
                            await oldCtx.close();
                        }
                        if (!mem || reset) {
                            const ctx = new (
                                AudioContext || webkitAudioContext
                            )({
                                samplingRate: 44100,
                            });
                            if (reset && ctx.state === "suspended") {
                                await ctx.resume();
                            }

                            await ctx.audioWorklet.addModule("audioworklet.js");

                            const bufferNode = new AudioWorkletNode(
                                ctx,
                                "wasm-processor",
                                {
                                    processorOptions: { memory, wasm },
                                },
                            );
                            const volume = ctx.createGain();
                            const gain = ctx.createGain();
                            gain.gain.value = handmadeMute.checked ? 0 : 1;
                            volume.gain.value = handmadeVolume.valueAsNumber;
                            bufferNode.connect(volume);
                            volume.connect(gain);
                            gain.connect(ctx.destination);

                            mem = {
                                audioCtx: ctx,
                                gain,
                                volume,
                                buffer: bufferNode,
                            };
                        }

                        return mem;
                    };
                })();
                handmadeMute.addEventListener("click", async (evt) => {
                    const target = evt.currentTarget;
                    const { audioCtx, gain, volume } = await audioCtxLazy(true);
                });
                handmadeMute.addEventListener("input", async (evt) => {
                    const target = evt.currentTarget;
                    const { audioCtx, gain, volume } = await audioCtxLazy();
                    if (audioCtx.state !== "running") {
                        gain.gain.value = 0;
                    }

                    const now = audioCtx.currentTime;
                    const fadeTime = 0.1;
                    handmadeGrid.classList.remove("loading");
                    gain.gain.cancelScheduledValues(now);
                    gain.gain.setValueAtTime(gain.gain.value, now);
                    gain.gain.linearRampToValueAtTime(
                        target.checked ? 0 : 1,
                        audioCtx.currentTime + fadeTime,
                    );
                });
                handmadeVolume.addEventListener("input", async (evt) => {
                    const target = evt.currentTarget;
                    const newVolume = target.valueAsNumber;
                    const { audioCtx, gain, volume } = await audioCtxLazy();

                    const now = audioCtx.currentTime;
                    const fadeTime = 0.1;
                    handmadeGrid.classList.remove("loading");
                    volume.gain.cancelScheduledValues(now);
                    volume.gain.linearRampToValueAtTime(
                        newVolume,
                        audioCtx.currentTime + fadeTime,
                    );
                });

                function resize() {
                    handmadeCanvas.width =
                        window.devicePixelRatio * handmadeCanvas.clientWidth;
                    handmadeCanvas.height =
                        window.devicePixelRatio * handmadeCanvas.clientHeight;
                    instance.exports.resize_viewport(
                        handmadeCanvas.width,
                        handmadeCanvas.height,
                    );
                    const style = getComputedStyle(document.documentElement);
                    const safeTop =
                        parseInt(style.getPropertyValue("--safe-top")) || 0;
                    const safeBottom =
                        parseInt(style.getPropertyValue("--safe-bottom")) || 0;
                    const safeLeft =
                        parseInt(style.getPropertyValue("--safe-left")) || 0;
                    const safeRight =
                        parseInt(style.getPropertyValue("--safe-right")) || 0;
                    const headerRect = handmadeHeader.getBoundingClientRect();
                    instance.exports.resize_viewport_safe(
                        headerRect.top * devicePixelRatio -
                            safeTop * devicePixelRatio +
                            headerRect.bottom * devicePixelRatio,
                        headerRect.left * devicePixelRatio,
                        safeBottom * devicePixelRatio,
                        headerRect.left * devicePixelRatio,
                    );
                    log("resize", handmadeCanvas.width, handmadeCanvas.height);
                }
                window.addEventListener("resize", resize);
                resize();

                handmadeCanvas.addEventListener("pointerenter", (evt) => {
                    if (evt.pointerType === "touch") {
                        return;
                    }
                    if (evt.isPrimary) {
                        instance.exports.mouse_move(
                            evt.clientX * window.devicePixelRatio,
                            evt.clientY * window.devicePixelRatio,
                        );
                        instance.exports.toggle_mouse(true);
                        log("enter");
                    }
                });

                handmadeCanvas.addEventListener("contextmenu", (evt) => {
                    evt.preventDefault();
                });

                handmadeCanvas.addEventListener("pointermove", (evt) => {
                    if (evt.pointerType === "touch") {
                        return;
                    }
                    if (evt.isPrimary) {
                        instance.exports.toggle_mouse(true);
                        instance.exports.mouse_move(
                            evt.clientX * window.devicePixelRatio,
                            evt.clientY * window.devicePixelRatio,
                        );
                    }
                });
                handmadeCanvas.addEventListener("pointerdown", async (evt) => {
                    if (evt.pointerType === "touch") {
                        return;
                    }
                    if (evt.isPrimary) {
                        const target = evt.currentTarget;
                        target.setPointerCapture(evt.pointerId);
                        instance.exports.mouse_move(
                            evt.clientX * window.devicePixelRatio,
                            evt.clientY * window.devicePixelRatio,
                        );
                        instance.exports.mouse_button_press(evt.button);
                    }
                    const { audioCtx, gain, volume } = await audioCtxLazy();
                });

                const MAX_FINGERS = 10;
                class FingerMap {
                    #free; // Min-Heap wÃ¤re overkill, Array reicht
                    #map; // touch.identifier -> index

                    constructor() {
                        this.#free = [];
                        this.#map = new Map();
                        for (let i = 0; i < MAX_FINGERS; i++)
                            this.#free.push(i);
                    }

                    allocIndex(id) {
                        if (this.#free.length === 0) return null;
                        const idx = this.#free.shift(); // kleinster freier Index
                        this.#map.set(id, idx);
                        return idx;
                    }

                    getIndex(id) {
                        return this.#map.get(id);
                    }

                    freeIndex(id) {
                        const idx = this.#map.get(id);
                        if (idx === undefined) return;
                        this.#map.delete(id);
                        this.#free.push(idx);
                        this.#free.sort((a, b) => a - b); // bei MAX=10 egal
                        return idx;
                    }
                }
                const fingers = new FingerMap();

                handmadeCanvas.addEventListener("touchstart", (evt) => {
                    evt.preventDefault();
                    for (let t of evt.changedTouches) {
                        const finger = fingers.allocIndex(t.identifier);
                        instance.exports.touch_finger_begin(
                            finger,
                            t.clientX * window.devicePixelRatio,
                            t.clientY * window.devicePixelRatio,
                        );
                    }
                });

                handmadeCanvas.addEventListener("touchmove", (evt) => {
                    evt.preventDefault();
                    for (let t of evt.changedTouches) {
                        const finger = fingers.getIndex(t.identifier);
                        if (finger !== undefined) {
                            instance.exports.touch_finger_move(
                                finger,
                                t.clientX * window.devicePixelRatio,
                                t.clientY * window.devicePixelRatio,
                            );
                        }
                    }
                });
                handmadeCanvas.addEventListener("touchend", (evt) => {
                    for (let t of evt.changedTouches) {
                        const finger = fingers.freeIndex(t.identifier);
                        if (finger !== undefined) {
                            instance.exports.touch_finger_end(
                                finger,
                                t.clientX * window.devicePixelRatio,
                                t.clientY * window.devicePixelRatio,
                            );
                        }
                    }
                });
                handmadeCanvas.addEventListener("touchcancel", (evt) => {
                    for (let t of evt.changedTouches) {
                        const finger = fingers.freeIndex(t.identifier);
                        if (finger !== undefined) {
                            instance.exports.touch_finger_end(
                                finger,
                                t.clientX * window.devicePixelRatio,
                                t.clientY * window.devicePixelRatio,
                            );
                        }
                    }
                });
                handmadeCanvas.addEventListener("pointerup", (evt) => {
                    if (evt.isPrimary) {
                        instance.exports.mouse_move(
                            evt.clientX * window.devicePixelRatio,
                            evt.clientY * window.devicePixelRatio,
                        );
                        instance.exports.mouse_button_release(evt.button);
                    }
                });
                handmadeCanvas.addEventListener("pointerleave", (evt) => {
                    if (evt.isPrimary) {
                        instance.exports.toggle_mouse(false);

                        log("leave");
                    }
                });
                handmadeStick.addEventListener("pointerdown", (evt) => {
                    evt.preventDefault();
                    evt.currentTarget.setPointerCapture(evt.pointerId);
                    moveStick(evt);
                });

                const stickPoint = handmadeStick.createSVGPoint();
                function moveStick(evt) {
                    stickPoint.x = evt.clientX;
                    stickPoint.y = evt.clientY;
                    const svgGlobal = stickPoint.matrixTransform(
                        handmadeStick.getScreenCTM().inverse(),
                    );
                    const angle = Math.atan2(svgGlobal.y, svgGlobal.x);
                    const mag = Math.min(
                        Math.hypot(svgGlobal.y, svgGlobal.x),
                        100,
                    );
                    handmadeStickNob.setAttribute(
                        "transform",
                        `translate(${Math.cos(angle) * mag},${Math.sin(angle) * mag})`,
                    );
                    instance.exports.controller_stick(
                        0,
                        (Math.cos(angle) * mag) / 100,
                        -(Math.sin(angle) * mag) / 100,
                    );
                    handmadeStick.classList.add("active");
                }
                handmadeStick.addEventListener("pointermove", (evt) => {
                    if (evt.currentTarget.hasPointerCapture(evt.pointerId)) {
                        evt.preventDefault();
                        moveStick(evt);
                    }
                });
                handmadeStick.addEventListener("pointerup", (evt) => {
                    if (evt.currentTarget.hasPointerCapture(evt.pointerId)) {
                        evt.preventDefault();
                        handmadeStickNob.setAttribute(
                            "transform",
                            "translate(0,0)",
                        );

                        handmadeStick.classList.remove("active");
                        instance.exports.controller_stick(0, 0, 0);
                    }
                });
                handmadeStick.addEventListener("pointercancel", (evt) => {
                    evt.preventDefault();
                    handmadeStickNob.setAttribute(
                        "transform",
                        "translate(0,0)",
                    );

                    handmadeStick.classList.remove("active");
                    instance.exports.controller_stick(0, 0, 0);
                });
                handmadeStick.addEventListener("lostpointercapture", (evt) => {
                    handmadeStickNob.setAttribute(
                        "transform",
                        "translate(0,0)",
                    );

                    handmadeStick.classList.remove("active");
                    instance.exports.controller_stick(0, 0, 0);
                });

                const buttons = {
                    MoveUp: 0,
                    MoveDown: 1,
                    MoveLeft: 2,
                    MoveRight: 3,
                    ActionUp: 4,
                    ActionDown: 5,
                    ActionLeft: 6,
                    ActionRight: 7,
                    LeftShoulder: 8,
                    RightShoulder: 9,
                    Menu: 10,
                    Back: 11,
                };
                const keymap = {
                    " ": "Menu",
                    Backspace: "Back",
                    w: "MoveUp",
                    s: "MoveDown",
                    a: "MoveLeft",
                    d: "MoveRight",
                    ArrowUp: "ActionUp",
                    ArrowLeft: "ActionLeft",
                    ArrowRight: "ActionRight",
                    ArrowDown: "ActionDown",
                };
                window.addEventListener("keydown", async (evt) => {
                    if (keymap[evt.key]) {
                        evt.preventDefault();

                        instance.exports.controller_button_press(
                            0,
                            buttons[keymap[evt.key]],
                        );
                    }
                });

                window.addEventListener("keyup", (evt) => {
                    if (keymap[evt.key]) {
                        evt.preventDefault();
                        instance.exports.controller_button_release(
                            0,
                            buttons[keymap[evt.key]],
                        );
                    }
                });

                handmadeVirtualButtons.addEventListener(
                    "pointerdown",
                    (evt) => {
                        if (evt.target.hasAttribute("data-mouse-button")) {
                            evt.preventDefault();
                            evt.target.setPointerCapture(evt.pointerId);

                            instance.exports.mouse_button_press(
                                parseInt(
                                    evt.target.getAttribute(
                                        "data-mouse-button",
                                    ),
                                ),
                            );
                        }
                        if (evt.target.hasAttribute("data-controller-button")) {
                            evt.preventDefault();
                            evt.target.setPointerCapture(evt.pointerId);

                            instance.exports.controller_button_press(
                                0,
                                parseInt(
                                    evt.target.getAttribute(
                                        "data-controller-button",
                                    ),
                                ),
                            );
                        }
                    },
                );

                handmadeVirtualButtons.addEventListener("pointerup", (evt) => {
                    if (evt.target.hasAttribute("data-mouse-button")) {
                        evt.preventDefault();
                        instance.exports.mouse_button_release(
                            parseInt(
                                evt.target.getAttribute("data-mouse-button"),
                            ),
                        );
                    }
                    if (evt.target.hasAttribute("data-controller-button")) {
                        evt.preventDefault();
                        instance.exports.controller_button_release(
                            0,
                            parseInt(
                                evt.target.getAttribute(
                                    "data-controller-button",
                                ),
                            ),
                        );
                    }
                });

                window.addEventListener("blur", (evt) => {
                    if (evt.currentTarget == evt.target) {
                        instance.exports.blur();
                    }
                });

                handmadeCanvas.addEventListener("wheel", (evt) => {
                    evt.preventDefault();
                    instance.exports.scroll_wheel(
                        evt.deltaX / 4,
                        evt.deltaY / 4,
                    );
                });
                const drawCtx = handmadeCanvas.getContext("2d");
                drawCtx.fillStyle = "#fed";
                drawCtx.fillRect(
                    0,
                    0,
                    handmadeCanvas.width,
                    handmadeCanvas.height,
                );
                let lastDrawTime = 0;
                const svgArena = (() => {
                    let index = {
                        rect: 0,
                        polygon: 0,
                    };
                    let allocated = {
                        rect: [],
                        polygon: [],
                    };
                    return {
                        reset: () => {
                            log("svg arena", allocated["rect"].length);
                            index["rect"] = 0;
                            index["polygon"] = 0;
                        },
                        alloc: (type) => {
                            if (index[type] >= allocated[type].length) {
                                allocated[type].push(
                                    document.createElementNS(
                                        "http://www.w3.org/2000/svg",
                                        type,
                                    ),
                                );
                            }
                            return allocated[type][index[type]++];
                        },
                    };
                })();
                const svgFragment = document.createDocumentFragment();
                const blockSize = 128;
                async function draw(now) {
                    const render_list_size = instance.exports.update_and_render(
                        (lastDrawTime ? now - lastDrawTime : 0) / 1000,
                    );
                    const { audioCtx, gain, volume } = await audioCtxLazy();
                    if (audioCtx.state !== "running") {
                        instance.exports.output_audio(blockSize);
                    }

                    log("render size", render_list_size);
                    const render_commands = new Float32Array(
                        memory.buffer,
                        renderBase,
                        render_list_size * 11,
                    );
                    const render_commands_int = new Int32Array(
                        memory.buffer,
                        renderBase,
                        render_list_size * 11,
                    );
                    drawCtx.fillStyle = "#fed";
                    drawCtx.fillRect(
                        0,
                        0,
                        handmadeCanvas.width,
                        handmadeCanvas.height,
                    );

                    if (handmadeOptionCanvas.checked) {
                        //  drawCtx.save();
                        //  drawCtx.translate(
                        //      +handmadeCanvas.width / 2,
                        //      +handmadeCanvas.height / 2,
                        //  );
                        //  drawCtx.scale(0.4, 0.4);
                        //  drawCtx.translate(
                        //      -handmadeCanvas.width / 2,
                        //      -handmadeCanvas.height / 2,
                        //  );

                        for (let r = 0; r < render_commands.length; r += 11) {
                            const type = render_commands_int[r + 0];
                            switch (type) {
                                case 0:
                                    {
                                        const minX = render_commands[r + 1];
                                        const minY = render_commands[r + 2];
                                        const maxX = render_commands[r + 3];
                                        const maxY = render_commands[r + 4];
                                        const colorR = render_commands[r + 5];
                                        const colorG = render_commands[r + 6];
                                        const colorB = render_commands[r + 7];
                                        const colorA = render_commands[r + 8];
                                        drawCtx.fillStyle = `rgba(${colorR * 255},${colorG * 255}, ${colorB * 255}, ${colorA})`;
                                        drawCtx.fillRect(
                                            Math.round(Math.min(maxX, minX)),
                                            Math.round(Math.min(maxY, minY)),
                                            Math.round(Math.abs(maxX - minX)),
                                            Math.round(Math.abs(maxY - minY)),
                                        );
                                    }
                                    break;

                                case 1:
                                    {
                                        const ax = Math.round(
                                            render_commands[r + 1],
                                        );
                                        const ay = Math.round(
                                            render_commands[r + 2],
                                        );
                                        const bx = Math.round(
                                            render_commands[r + 3],
                                        );
                                        const by = Math.round(
                                            render_commands[r + 4],
                                        );
                                        const cx = Math.round(
                                            render_commands[r + 5],
                                        );
                                        const cy = Math.round(
                                            render_commands[r + 6],
                                        );
                                        const colorR = render_commands[r + 7];
                                        const colorG = render_commands[r + 8];
                                        const colorB = render_commands[r + 9];
                                        const colorA = render_commands[r + 10];
                                        drawCtx.fillStyle = `rgba(${colorR * 255},${colorG * 255}, ${colorB * 255}, ${colorA})`;
                                        drawCtx.beginPath();
                                        drawCtx.moveTo(ax, ay);
                                        drawCtx.lineTo(bx, by);
                                        drawCtx.lineTo(cx, cy);
                                        drawCtx.closePath();
                                        drawCtx.fill();
                                    }
                                    break;
                                default: {
                                }
                            }
                        }
                        drawCtx.restore();
                    }
                    {
                        svgArena.reset();

                        if (handmadeOptionSvg.checked) {
                            handmadeSvg.setAttribute(
                                "viewBox",
                                `0 0 ${handmadeCanvas.width} ${handmadeCanvas.height}`,
                            );
                            handmadeSvg.replaceChild(
                                handmadeSvgInner.cloneNode(false),
                                handmadeSvgInner,
                            );
                            for (
                                let r = 0;
                                r < render_commands.length;
                                r += 11
                            ) {
                                const type = render_commands_int[r + 0];
                                switch (type) {
                                    case 0:
                                        {
                                            const svgRect =
                                                svgArena.alloc("rect");
                                            const minX = render_commands[r + 1];
                                            const minY = render_commands[r + 2];
                                            const maxX = render_commands[r + 3];
                                            const maxY = render_commands[r + 4];
                                            const colorR =
                                                render_commands[r + 5];
                                            const colorG =
                                                render_commands[r + 6];
                                            const colorB =
                                                render_commands[r + 7];
                                            const colorA =
                                                render_commands[r + 8];

                                            svgRect.setAttribute(
                                                "shape-rendering",
                                                "crispEdges",
                                            );
                                            svgRect.setAttribute(
                                                "x",
                                                Math.min(maxX, minX),
                                            );
                                            svgRect.setAttribute(
                                                "y",
                                                Math.min(maxY, minY),
                                            );
                                            svgRect.setAttribute(
                                                "width",
                                                Math.abs(maxX - minX),
                                            );
                                            svgRect.setAttribute(
                                                "height",
                                                Math.abs(maxY - minY),
                                            );
                                            svgRect.setAttribute(
                                                "fill",
                                                `rgba(${colorR * 255},${colorG * 255}, ${colorB * 255}, ${colorA})`,
                                            );
                                            svgFragment.appendChild(svgRect);
                                        }
                                        break;

                                    case 1:
                                        {
                                            const ax = render_commands[r + 1];
                                            const ay = render_commands[r + 2];
                                            const bx = render_commands[r + 3];
                                            const by = render_commands[r + 4];
                                            const cx = render_commands[r + 5];
                                            const cy = render_commands[r + 6];
                                            const colorR =
                                                render_commands[r + 7];
                                            const colorG =
                                                render_commands[r + 8];
                                            const colorB =
                                                render_commands[r + 9];
                                            const colorA =
                                                render_commands[r + 10];

                                            const svgPoly =
                                                svgArena.alloc("polygon");
                                            svgPoly.setAttribute(
                                                "shape-rendering",
                                                "crispEdges",
                                            );
                                            svgPoly.setAttribute(
                                                "points",
                                                `${ax} ${ay} ${bx} ${by} ${cx} ${cy}`,
                                            );
                                            svgPoly.setAttribute(
                                                "fill",
                                                `rgba(${colorR * 255},${colorG * 255}, ${colorB * 255}, ${colorA})`,
                                            );
                                            svgFragment.appendChild(svgPoly);
                                        }
                                        break;
                                    default: {
                                    }
                                }
                            }

                            handmadeSvgInner.appendChild(svgFragment);
                        } else if (handmadeSvgInner.childElementCount) {
                            handmadeSvg.replaceChild(
                                handmadeSvgInner.cloneNode(false),
                                handmadeSvgInner,
                            );
                        }
                    }
                    lastDrawTime = now;
                    requestAnimationFrame(draw);
                }
                requestAnimationFrame(draw);
            </script>
            <script type="module">
                (function () {
                    const splashTemplate =
                        document.head.querySelector('link[rel="icon"]');
                    const iOSDevice =
                        !!navigator.platform.match(/iPhone|iPod|iPad/);

                    if (!splashTemplate) {
                        return;
                    }

                    const splashHref = splashTemplate.getAttribute("href");
                    const splashColor =
                        splashTemplate.getAttribute("data-color") || "white";
                    const size = splashTemplate.hasAttribute("data-size")
                        ? splashTemplate.getAttribute("data-size")
                        : 0.5;
                    const iconPadding = splashTemplate.hasAttribute(
                        "data-padding",
                    )
                        ? splashTemplate.getAttribute("data-padding")
                        : 10;
                    const appIconSize = splashTemplate.hasAttribute(
                        "data-icon-size",
                    )
                        ? splashTemplate.getAttribute("data-icon-size")
                        : 180;

                    if (!splashHref) {
                        return;
                    }

                    const deviceWidth = screen.width;
                    const deviceHeight = screen.height;
                    const pixelRatio = window.devicePixelRatio || 1;
                    const canvas = document.createElement("canvas");
                    const canvas2 = document.createElement("canvas");
                    const canvas3 = document.createElement("canvas");
                    const ctx = canvas.getContext("2d");
                    const ctx2 = canvas2.getContext("2d");
                    const ctx3 = canvas3.getContext("2d");

                    const iconImage = new Image();

                    iconImage.onerror = function () {
                        //throw new Error("Failed to load icon image");
                    };

                    iconImage.onload = function () {
                        // Calculate the icon size based on the device's pixel ratio
                        const defaultSize =
                            (deviceWidth * size || iconImage.width) *
                            pixelRatio;
                        const imageRatio = iconImage.width
                            ? iconImage.height / iconImage.width
                            : 1;

                        const iconSizeW = defaultSize;
                        const iconSizeH = defaultSize * imageRatio;

                        canvas.width = deviceWidth * pixelRatio;
                        canvas2.height = canvas.width;
                        canvas.height = deviceHeight * pixelRatio;
                        canvas2.width = canvas.height;
                        ctx.fillStyle = splashColor;
                        ctx2.fillStyle = splashColor;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx2.fillRect(0, 0, canvas2.width, canvas2.height);

                        canvas3.width = appIconSize;
                        canvas3.height = appIconSize;
                        ctx3.fillStyle = splashColor;
                        ctx3.fillRect(0, 0, canvas3.width, canvas3.height);

                        // Calculate the position to center the icon
                        const x = (canvas.width - iconSizeW) / 2;
                        const y = (canvas.height - iconSizeH) / 2;
                        const x2 = (canvas2.width - iconSizeW) / 2;
                        const y2 = (canvas2.height - iconSizeH) / 2;
                        const x3 = (canvas3.width - iconSizeW) / 2;
                        const y3 = (canvas3.height - iconSizeH) / 2;
                        // Draw the icon with the calculated size
                        ctx.drawImage(iconImage, x, y, iconSizeW, iconSizeH);
                        ctx2.drawImage(iconImage, x2, y2, iconSizeW, iconSizeH);
                        ctx3.drawImage(
                            iconImage,
                            iconPadding,
                            iconPadding,
                            appIconSize - 2 * iconPadding,
                            appIconSize - 2 * iconPadding,
                        );
                        const imageDataURLPortrait =
                            canvas.toDataURL("image/png");
                        const imageDataURLLandscape =
                            canvas2.toDataURL("image/png");
                        const imageDataURLIcon = canvas3.toDataURL("image/png");

                        const appleTouchStartupImagePortrait =
                            document.createElement("link");
                        appleTouchStartupImagePortrait.setAttribute(
                            "rel",
                            "apple-touch-startup-image",
                        );
                        appleTouchStartupImagePortrait.setAttribute(
                            "media",
                            "screen and (orientation: portrait)",
                        );
                        appleTouchStartupImagePortrait.setAttribute(
                            "href",
                            imageDataURLPortrait,
                        );
                        document.head.appendChild(
                            appleTouchStartupImagePortrait,
                        );

                        const appleTouchStartupImageLandscape =
                            document.createElement("link");
                        appleTouchStartupImageLandscape.setAttribute(
                            "rel",
                            "apple-touch-startup-image",
                        );
                        appleTouchStartupImageLandscape.setAttribute(
                            "media",
                            "screen and (orientation: landscape)",
                        );
                        appleTouchStartupImageLandscape.setAttribute(
                            "href",
                            imageDataURLLandscape,
                        );
                        document.head.appendChild(
                            appleTouchStartupImageLandscape,
                        );

                        const appleTouchAppIcon =
                            document.createElement("link");
                        appleTouchAppIcon.setAttribute(
                            "rel",
                            "apple-touch-icon",
                        );
                        appleTouchAppIcon.setAttribute(
                            "sizes",
                            [appIconSize, appIconSize].join("x"),
                        );
                        appleTouchAppIcon.setAttribute(
                            "href",
                            imageDataURLIcon,
                        );
                        document.head.appendChild(appleTouchAppIcon);
                    };

                    iconImage.src = splashHref;
                })();
            </script>
            <style>
                body {
                    accent-color: deeppink;
                    font-family: monospace;
                    margin: 0;
                    user-select: none;
                }
                header {
                    display: flex;
                    gap: 1ex;
                    flex-direction: column;
                    color: #fff;
                    background-color: #333a;
                    padding: 1em;
                    grid-column: 1 / -1;
                }
                header > p {
                    margin: 0;
                }
                h1 > img {
                    width: 1em;
                    height: 1em;
                    vertical-align: middle;
                    margin: 0;
                }
                h1 {
                    grid-column: 1 / -1;
                    grid-row: 1 / span 1;
                    margin: 0;
                    display: flex;
                    gap: 0.75ex;
                    align-items: center;
                }
                h2 {
                    margin: 0;
                }
                .app {
                    padding: 2em;
                    display: flex;
                    flex-direction: column;
                    gap: 1em;
                }
                .grid {
                    position: absolute;
                    z-index: 0;
                    top: 0;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    display: grid;
                    grid-template-columns: auto;
                    grid-template-rows: auto;
                    gap: 1em;
                    justify-content: stretch;
                    align-items: stretch;
                    height: 100%;
                    width: 100%;
                    height: 100vh;
                    width: 100vw;
                    box-sizing: border-box;
                    overflow: auto;
                    touch-action: manipulation;
                    scroll-behavior: smooth;
                    overscroll-behavior: contain;
                    scrollbar-gutter: thin;
                    padding: env(safe-area-inset-top) env(safe-area-inset-right)
                        env(safe-area-inset-bottom) env(safe-area-inset-left);
                }
                .grid-inner {
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    grid-auto-flow: column;
                    grid-template-rows: auto 1fr;
                    justify-content: space-between;
                    align-items: start;
                    pointer-events: none;
                    box-sizing: border-box;
                    padding: 1ex;
                    z-index: 10;
                }
                .grid-inner > * {
                    pointer-events: all;
                    touch-action: manipulation;
                }
                .loading {
                    opacity: 0.1;
                }
                section {
                    display: flex;
                    flex-direction: column;
                    justify-content: stretch;
                    flex-grow: 1;
                }
                pre {
                    background-color: #111a;
                    color: #fff;
                    padding: 1em;
                    margin: 0;
                    flex-grow: 1;
                }
                canvas {
                    background-color: lemonchiffon;
                }
                summary {
                    padding: 1em;
                    cursor: pointer;
                    background-color: #eee;
                    user-select: none;
                }
                .scroller {
                    max-height: 30vh;
                    overflow: auto;
                }
                label {
                    display: flex;
                    align-items: center;
                    gap: 1ex;
                    justify-content: start;
                    justify-self: start;
                    background-color: #333a;
                    color: #fff;
                    padding: 0.5ex 1.5em 0.5ex 1.5ex;
                    user-select: none;
                }
                label:has([type="range"]) {
                    flex-grow: 1;
                }
                button {
                    background-color: #111;
                    color: #fff;
                    border: none;
                    border-radius: 4px;
                    padding: 1ex;
                    font: inherit;
                    cursor: pointer;
                }
                button:hover {
                    background-color: #333;
                }

                button:active {
                    background-color: #000;
                    color: #eee;
                }
                input[type="range"] {
                    margin: 0;
                    flex-grow: 1;
                    padding: 1.5ex 0;
                }

                input[type="checkbox"] {
                    height: 2em;
                }
                fieldset {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 1ex;
                    padding: 0;
                    margin: 0 0 1ex;
                    border: none;
                    justify-self: end;
                }
                .controls {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 1em;
                    justify-content: start;
                    flex-grow: 1;
                }
                html,
                body {
                    margin: 0;
                    padding: 0;
                    width: 100%;
                    height: 100%;
                    overflow: hidden;
                    overscroll-behavior: none;
                }
                canvas {
                    position: absolute;
                    display: block;
                    margin: 0;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    width: 100%;
                    height: 100%;
                    width: 100vw;
                    height: 100vh;
                    touch-action: none;
                }
                .panel {
                    align-self: end;
                }
                .log h2 {
                    background-color: #111;
                    color: #fff;
                    font-size: 1em;
                    padding: 1ex;
                }
                summary {
                    background-color: #111;
                    color: #fff;
                }

                details > div {
                    padding: 1em;
                    background-color: #f0f0f0;
                }
                kbd {
                    background-color: #ddd;
                    border: 1px solid #ccc;
                    color: #000;
                    border-radius: 3px;
                    padding: 2px 4px;
                    display: inline-block;
                }
                a {
                    color: inherit;
                }
                .stick {
                    display: block;
                    position: fixed;
                    width: 200px;
                    height: 200px;
                    bottom: 0;
                    right: 0;
                    cursor: move;
                    opacity: 0.5;
                    touch-action: none;
                    z-index: 10;
                    margin-right: env(safe-area-inset-right);
                    margin-bottom: env(safe-area-inset-bottom);
                }
                .stick.active {
                    pointer-events: none;
                    opacity: 1;
                }

                .svg-render {
                    position: absolute;
                    pointer-events: none;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    width: 100%;
                    height: 100%;
                    width: 100vw;
                    height: 100vh;
                    touch-action: none;
                }
                :root {
                    --safe-top: env(safe-area-inset-top);
                    --safe-bottom: env(safe-area-inset-bottom);
                    --safe-left: env(safe-area-inset-left);
                    --safe-right: env(safe-area-inset-right);
                }
            </style>
        </div>
    </body>
</html>
