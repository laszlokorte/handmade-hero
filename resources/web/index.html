<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="icon" href="favicon.svg" />
        <title>Handmade Hero</title>
    </head>
    <body>
        <canvas id="handmadeCanvas" width="800" height="600"></canvas>
        <svg id="handmadeStick" viewBox="-150 -150 300 300" class="stick">
            <circle cx="0" cy="0" r="100" fill="#1115"></circle>
            <circle cx="0" cy="0" r="10" fill="#111a"></circle>
            <circle
                id="handmadeStickNob"
                cx="0"
                cy="0"
                r="50"
                fill="#111a"
            ></circle>
        </svg>
        <svg id="handmadeSvg" viewBox="-150 -150 300 300" class="svg-render">
            <g id="handmadeSvgInner"></g>
        </svg>
        <div class="app">
            <div class="grid" id="handmadeGrid">
                <header>
                    <h1>
                        <img src="favicon.svg" alt="Icon" />
                        Handmade Hero
                    </h1>
                    <p>
                        Web Version of an
                        <a
                            href="https://guide.handmadehero.org/"
                            target="_blank"
                            >Handmade Hero Style Game</a
                        >
                    </p>
                </header>

                <section class="panel">
                    <fieldset>
                        <div class="controls">
                            <label>
                                <input
                                    type="checkbox"
                                    id="handmadeMute"
                                    checked="checked"
                                />
                                Muted
                            </label>
                            <label>
                                Volume:
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    id="handmadeVolume"
                                    value="0.4"
                                />
                            </label>
                        </div>
                    </fieldset>
                    <details>
                        <summary>Settings</summary>
                        <div class="controls">
                            <label>
                                <input
                                    type="checkbox"
                                    id="handmadeOptionCanvas"
                                    checked
                                />
                                Render Canvas
                            </label>
                            <label>
                                <input type="checkbox" id="handmadeOptionSvg" />
                                Render SVG
                            </label>

                            <label>
                                <input
                                    type="checkbox"
                                    id="handmadeOptionWebGl"
                                />
                                Render WebGL
                            </label>
                        </div>
                    </details>
                    <details>
                        <summary>About</summary>
                        <div>
                            <p>
                                Press <kbd>Right Arrow</kbd> to spawn a new
                                player.
                            </p>
                            <p>
                                Press <kbd>W</kbd>, <kbd>A</kbd>, <kbd>S</kbd>,
                                <kbd>D</kbd> to move around.
                            </p>
                            <p>
                                Press <kbd>Backspace</kbd> to build a wall or
                                use the left and right mouse buttons to
                                draw/erase walls.
                            </p>
                            <p>
                                Press middle mouse button to pan the camera. Use
                                the scrollwheel to pan the camera up and down or
                                hold <kbd>Space bar</kbd> while scrolling to
                                zoom in and out.
                            </p>
                        </div>
                    </details>

                    <details>
                        <summary>Buttons</summary>
                        <div id="handmadeVirtualButtons">
                            <fieldset>
                                <label>Mouse</label>
                                <div class="controls">
                                    <button data-mouse-button="0">Left</button>
                                    <button data-mouse-button="1">
                                        Middle
                                    </button>
                                    <button data-mouse-button="2">Right</button>
                                    <button data-mouse-button="3">
                                        Extra1
                                    </button>
                                    <button data-mouse-button="4">
                                        Extra2
                                    </button>
                                </div>
                            </fieldset>
                            <fieldset>
                                <label>Controller #0</label>
                                <div class="controls">
                                    <button data-controller-button="0">
                                        MoveUp
                                    </button>
                                    <button data-controller-button="1">
                                        MoveDown
                                    </button>
                                    <button data-controller-button="2">
                                        MoveLeft
                                    </button>
                                    <button data-controller-button="3">
                                        MoveRight
                                    </button>
                                    <button data-controller-button="4">
                                        ActionUp
                                    </button>
                                    <button data-controller-button="5">
                                        ActionDown
                                    </button>
                                    <button data-controller-button="6">
                                        ActionLeft
                                    </button>
                                    <button data-controller-button="7">
                                        ActionRight
                                    </button>
                                    <button data-controller-button="8">
                                        LeftShoulder
                                    </button>
                                    <button data-controller-button="9">
                                        RightShoulder
                                    </button>
                                    <button data-controller-button="10">
                                        Menu
                                    </button>
                                    <button data-controller-button="11">
                                        Back
                                    </button>
                                </div>
                            </fieldset>
                        </div>
                    </details>

                    <details>
                        <summary>Log</summary>
                        <pre id="handmadeLog"></pre>
                    </details>
                </section>
            </div>

            <script type="module">
                function log(label, ...args) {
                    if (handmadeLog.childNodes.length > 5) {
                        handmadeLog.removeChild(handmadeLog.firstChild);
                    }
                    handmadeLog.appendChild(
                        document.createTextNode(
                            label + ": " + args.join(", ") + "\n",
                        ),
                    );
                }
                const memory = new WebAssembly.Memory({
                    initial: 32,
                    maximum: 32,
                    shared: true,
                });

                const wasm = await WebAssembly.compileStreaming(
                    fetch("handmade.wasm"),
                );
                const instance = await WebAssembly.instantiate(wasm, {
                    env: {
                        memory,
                    },
                });

                const blockSize = 128;
                handmadeMute.checked = true;

                const renderBase = instance.exports.get_render_list();

                instance.exports.setup();
                instance.exports.controller_button_press(0, 7);
                const audioCtxLazy = (() => {
                    let prom = null;
                    return () => {
                        if (!prom) {
                            prom = new Promise(async (res) => {
                                const ctx = new AudioContext({
                                    samplingRate: 44100,
                                });
                                await ctx.audioWorklet.addModule(
                                    "audioworklet.js",
                                );

                                const bufferNode = new AudioWorkletNode(
                                    ctx,
                                    "wasm-processor",
                                    {
                                        processorOptions: { memory, wasm },
                                    },
                                );
                                const volume = ctx.createGain();
                                const gain = ctx.createGain();
                                gain.gain.value = handmadeMute.checked ? 0 : 1;
                                volume.gain.value =
                                    handmadeVolume.valueAsNumber;
                                bufferNode.connect(volume);
                                volume.connect(gain);
                                gain.connect(ctx.destination);

                                res({ audioCtx: ctx, gain, volume });
                            });
                        }

                        return prom;
                    };
                })();
                handmadeMute.addEventListener("input", async (evt) => {
                    const target = evt.currentTarget;
                    const { audioCtx, gain, volume } = await audioCtxLazy();
                    if (audioCtx.state !== "running") {
                        gain.gain.value = 0;
                    }
                    await audioCtx.resume();
                    const now = audioCtx.currentTime;
                    const fadeTime = 0.1;
                    handmadeGrid.classList.remove("loading");
                    gain.gain.cancelScheduledValues(now);
                    gain.gain.setValueAtTime(gain.gain.value, now);
                    gain.gain.linearRampToValueAtTime(
                        target.checked ? 0 : 1,
                        audioCtx.currentTime + fadeTime,
                    );
                });
                handmadeVolume.addEventListener("input", async (evt) => {
                    const target = evt.currentTarget;
                    const { audioCtx, gain, volume } = await audioCtxLazy();
                    await audioCtx.resume();
                    const now = audioCtx.currentTime;
                    const fadeTime = 0.1;
                    handmadeGrid.classList.remove("loading");
                    volume.gain.cancelScheduledValues(now);
                    volume.gain.setValueAtTime(gain.gain.value, now);
                    volume.gain.linearRampToValueAtTime(
                        target.valueAsNumber,
                        audioCtx.currentTime + fadeTime,
                    );
                });

                function resize() {
                    handmadeCanvas.width =
                        window.devicePixelRatio * handmadeCanvas.clientWidth;
                    handmadeCanvas.height =
                        window.devicePixelRatio * handmadeCanvas.clientHeight;
                    instance.exports.resize_viewport(
                        handmadeCanvas.width,
                        handmadeCanvas.height,
                    );
                    log("resize", handmadeCanvas.width, handmadeCanvas.height);
                }
                window.addEventListener("resize", resize);
                resize();

                handmadeCanvas.addEventListener("pointerenter", (evt) => {
                    if (evt.isPrimary) {
                        instance.exports.mouse_move(
                            evt.clientX * window.devicePixelRatio,
                            evt.clientY * window.devicePixelRatio,
                        );
                        instance.exports.toggle_mouse(true);
                        log("enter");
                    }
                });

                handmadeCanvas.addEventListener("contextmenu", (evt) => {
                    evt.preventDefault();
                });

                handmadeCanvas.addEventListener("pointermove", (evt) => {
                    if (evt.isPrimary) {
                        instance.exports.toggle_mouse(true);
                        instance.exports.mouse_move(
                            evt.clientX * window.devicePixelRatio,
                            evt.clientY * window.devicePixelRatio,
                        );
                    }
                });
                handmadeCanvas.addEventListener("pointerdown", async (evt) => {
                    if (evt.isPrimary) {
                        const target = evt.currentTarget;
                        target.setPointerCapture(evt.pointerId);
                        instance.exports.mouse_move(
                            evt.clientX * window.devicePixelRatio,
                            evt.clientY * window.devicePixelRatio,
                        );
                        instance.exports.mouse_button_press(evt.button);
                    }
                    const { audioCtx, gain, volume } = await audioCtxLazy();
                    await audioCtx.resume();
                });
                handmadeCanvas.addEventListener("pointerup", (evt) => {
                    if (evt.isPrimary) {
                        instance.exports.mouse_move(
                            evt.clientX * window.devicePixelRatio,
                            evt.clientY * window.devicePixelRatio,
                        );
                        instance.exports.mouse_button_release(evt.button);
                    }
                });
                handmadeCanvas.addEventListener("pointerleave", () => {
                    if (evt.isPrimary) {
                        instance.exports.toggle_mouse(false);

                        log("leave");
                    }
                });
                handmadeStick.addEventListener("pointerdown", (evt) => {
                    evt.preventDefault();
                    evt.currentTarget.setPointerCapture(evt.pointerId);
                    moveStick(evt);
                });

                const stickPoint = handmadeStick.createSVGPoint();
                function moveStick(evt) {
                    stickPoint.x = evt.clientX;
                    stickPoint.y = evt.clientY;
                    var svgGlobal = stickPoint.matrixTransform(
                        handmadeStick.getScreenCTM().inverse(),
                    );
                    const angle = Math.atan2(svgGlobal.y, svgGlobal.x);
                    const mag = Math.min(
                        Math.hypot(svgGlobal.y, svgGlobal.x),
                        100,
                    );
                    handmadeStickNob.setAttribute(
                        "transform",
                        `translate(${Math.cos(angle) * mag},${Math.sin(angle) * mag})`,
                    );
                    instance.exports.controller_stick(
                        0,
                        (Math.cos(angle) * mag) / 100,
                        -(Math.sin(angle) * mag) / 100,
                    );
                }
                handmadeStick.addEventListener("pointermove", (evt) => {
                    if (evt.currentTarget.hasPointerCapture(evt.pointerId)) {
                        evt.preventDefault();
                        moveStick(evt);
                    }
                });
                handmadeStick.addEventListener("pointerup", (evt) => {
                    if (evt.currentTarget.hasPointerCapture(evt.pointerId)) {
                        evt.preventDefault();
                        handmadeStickNob.setAttribute(
                            "transform",
                            "translate(0,0)",
                        );

                        instance.exports.controller_stick(0, 0, 0);
                    }
                });
                handmadeStick.addEventListener("lostpointercapture", (evt) => {
                    if (evt.isPrimary) {
                        handmadeStickNob.setAttribute(
                            "transform",
                            "translate(0,0)",
                        );

                        instance.exports.controller_stick(0, 0, 0);
                    }
                });

                const buttons = {
                    MoveUp: 0,
                    MoveDown: 1,
                    MoveLeft: 2,
                    MoveRight: 3,
                    ActionUp: 4,
                    ActionDown: 5,
                    ActionLeft: 6,
                    ActionRight: 7,
                    LeftShoulder: 8,
                    RightShoulder: 9,
                    Menu: 10,
                    Back: 11,
                };
                const keymap = {
                    " ": "Menu",
                    Backspace: "Back",
                    w: "MoveUp",
                    s: "MoveDown",
                    a: "MoveLeft",
                    d: "MoveRight",
                    ArrowUp: "ActionUp",
                    ArrowLeft: "ActionLeft",
                    ArrowRight: "ActionRight",
                    ArrowDown: "ActionDown",
                };
                window.addEventListener("keydown", async (evt) => {
                    if (keymap[evt.key]) {
                        evt.preventDefault();

                        instance.exports.controller_button_press(
                            0,
                            buttons[keymap[evt.key]],
                        );
                    }
                });

                window.addEventListener("keyup", (evt) => {
                    if (keymap[evt.key]) {
                        evt.preventDefault();
                        instance.exports.controller_button_release(
                            0,
                            buttons[keymap[evt.key]],
                        );
                    }
                });

                handmadeVirtualButtons.addEventListener(
                    "pointerdown",
                    (evt) => {
                        if (evt.target.hasAttribute("data-mouse-button")) {
                            evt.preventDefault();
                            evt.target.setPointerCapture(evt.pointerId);

                            instance.exports.mouse_button_press(
                                parseInt(
                                    evt.target.getAttribute(
                                        "data-mouse-button",
                                    ),
                                ),
                            );
                        }
                        if (evt.target.hasAttribute("data-controller-button")) {
                            evt.preventDefault();
                            evt.target.setPointerCapture(evt.pointerId);

                            instance.exports.controller_button_press(
                                0,
                                parseInt(
                                    evt.target.getAttribute(
                                        "data-controller-button",
                                    ),
                                ),
                            );
                        }
                    },
                );

                handmadeVirtualButtons.addEventListener("pointerup", (evt) => {
                    if (evt.target.hasAttribute("data-mouse-button")) {
                        evt.preventDefault();
                        instance.exports.mouse_button_release(
                            parseInt(
                                evt.target.getAttribute("data-mouse-button"),
                            ),
                        );
                    }
                    if (evt.target.hasAttribute("data-controller-button")) {
                        evt.preventDefault();
                        instance.exports.controller_button_release(
                            0,
                            parseInt(
                                evt.target.getAttribute(
                                    "data-controller-button",
                                ),
                            ),
                        );
                    }
                });

                window.addEventListener("blur", (evt) => {
                    if (evt.currentTarget == evt.target) {
                        instance.exports.blur();
                    }
                });

                handmadeCanvas.addEventListener("wheel", (evt) => {
                    evt.preventDefault();
                    instance.exports.scroll_wheel(
                        evt.deltaX / 4,
                        evt.deltaY / 4,
                    );
                });
                const drawCtx = handmadeCanvas.getContext("2d");
                drawCtx.fillStyle = "#fed";
                drawCtx.fillRect(
                    0,
                    0,
                    handmadeCanvas.width,
                    handmadeCanvas.height,
                );
                let lastDrawTime = 0;
                const svgArena = (() => {
                    let index = {
                        rect: 0,
                        polygon: 0,
                    };
                    let allocated = {
                        rect: [],
                        polygon: [],
                    };
                    return {
                        reset: () => {
                            log("svg arena", allocated["rect"].length);
                            index["rect"] = 0;
                            index["polygon"] = 0;
                        },
                        alloc: (type) => {
                            if (index[type] >= allocated[type].length) {
                                allocated[type].push(
                                    document.createElementNS(
                                        "http://www.w3.org/2000/svg",
                                        type,
                                    ),
                                );
                            }
                            return allocated[type][index[type]++];
                        },
                    };
                })();
                const svgFragment = document.createDocumentFragment();
                async function draw(now) {
                    const render_list_size = instance.exports.update_and_render(
                        (lastDrawTime ? now - lastDrawTime : 0) / 1000,
                    );
                    const { audioCtx, gain, volume } = await audioCtxLazy();
                    if (audioCtx.state !== "running") {
                        instance.exports.output_audio(128);
                    }

                    log("render size", render_list_size);
                    const render_commands = new Float32Array(
                        memory.buffer,
                        renderBase,
                        render_list_size * 11,
                    );
                    const render_commands_int = new Int32Array(
                        memory.buffer,
                        renderBase,
                        render_list_size * 11,
                    );
                    drawCtx.fillStyle = "#fed";
                    drawCtx.fillRect(
                        0,
                        0,
                        handmadeCanvas.width,
                        handmadeCanvas.height,
                    );

                    if (handmadeOptionCanvas.checked) {
                        //  drawCtx.save();
                        //  drawCtx.translate(
                        //      +handmadeCanvas.width / 2,
                        //      +handmadeCanvas.height / 2,
                        //  );
                        //  drawCtx.scale(0.4, 0.4);
                        //  drawCtx.translate(
                        //      -handmadeCanvas.width / 2,
                        //      -handmadeCanvas.height / 2,
                        //  );

                        for (let r = 0; r < render_commands.length; r += 11) {
                            const type = render_commands_int[r + 0];
                            switch (type) {
                                case 0:
                                    {
                                        const minX = render_commands[r + 1];
                                        const minY = render_commands[r + 2];
                                        const maxX = render_commands[r + 3];
                                        const maxY = render_commands[r + 4];
                                        const colorR = render_commands[r + 5];
                                        const colorG = render_commands[r + 6];
                                        const colorB = render_commands[r + 7];
                                        const colorA = render_commands[r + 8];
                                        drawCtx.fillStyle = `rgba(${colorR * 255},${colorG * 255}, ${colorB * 255}, ${colorA})`;
                                        drawCtx.fillRect(
                                            Math.min(maxX, minX),
                                            Math.min(maxY, minY),
                                            Math.abs(maxX - minX),
                                            Math.abs(maxY - minY),
                                        );
                                    }
                                    break;

                                case 1:
                                    {
                                        const ax = render_commands[r + 1];
                                        const ay = render_commands[r + 2];
                                        const bx = render_commands[r + 3];
                                        const by = render_commands[r + 4];
                                        const cx = render_commands[r + 5];
                                        const cy = render_commands[r + 6];
                                        const colorR = render_commands[r + 7];
                                        const colorG = render_commands[r + 8];
                                        const colorB = render_commands[r + 9];
                                        const colorA = render_commands[r + 10];
                                        drawCtx.fillStyle = `rgba(${colorR * 255},${colorG * 255}, ${colorB * 255}, ${colorA})`;
                                        drawCtx.beginPath();
                                        drawCtx.moveTo(ax, ay);
                                        drawCtx.lineTo(bx, by);
                                        drawCtx.lineTo(cx, cy);
                                        drawCtx.closePath();
                                        drawCtx.fill();
                                    }
                                    break;
                                default: {
                                }
                            }
                        }
                        drawCtx.restore();
                    }
                    {
                        svgArena.reset();

                        if (handmadeOptionSvg.checked) {
                            handmadeSvg.setAttribute(
                                "viewBox",
                                `0 0 ${handmadeCanvas.width} ${handmadeCanvas.height}`,
                            );
                            handmadeSvg.replaceChild(
                                handmadeSvgInner.cloneNode(false),
                                handmadeSvgInner,
                            );
                            for (
                                let r = 0;
                                r < render_commands.length;
                                r += 11
                            ) {
                                const type = render_commands_int[r + 0];
                                switch (type) {
                                    case 0:
                                        {
                                            const svgRect =
                                                svgArena.alloc("rect");
                                            const minX = render_commands[r + 1];
                                            const minY = render_commands[r + 2];
                                            const maxX = render_commands[r + 3];
                                            const maxY = render_commands[r + 4];
                                            const colorR =
                                                render_commands[r + 5];
                                            const colorG =
                                                render_commands[r + 6];
                                            const colorB =
                                                render_commands[r + 7];
                                            const colorA =
                                                render_commands[r + 8];

                                            svgRect.setAttribute(
                                                "shape-rendering",
                                                "crispEdges",
                                            );
                                            svgRect.setAttribute(
                                                "x",
                                                Math.min(maxX, minX),
                                            );
                                            svgRect.setAttribute(
                                                "y",
                                                Math.min(maxY, minY),
                                            );
                                            svgRect.setAttribute(
                                                "width",
                                                Math.abs(maxX - minX),
                                            );
                                            svgRect.setAttribute(
                                                "height",
                                                Math.abs(maxY - minY),
                                            );
                                            svgRect.setAttribute(
                                                "fill",
                                                `rgba(${colorR * 255},${colorG * 255}, ${colorB * 255}, ${colorA})`,
                                            );
                                            svgFragment.appendChild(svgRect);
                                        }
                                        break;

                                    case 1:
                                        {
                                            const ax = render_commands[r + 1];
                                            const ay = render_commands[r + 2];
                                            const bx = render_commands[r + 3];
                                            const by = render_commands[r + 4];
                                            const cx = render_commands[r + 5];
                                            const cy = render_commands[r + 6];
                                            const colorR =
                                                render_commands[r + 7];
                                            const colorG =
                                                render_commands[r + 8];
                                            const colorB =
                                                render_commands[r + 9];
                                            const colorA =
                                                render_commands[r + 10];

                                            const svgPoly =
                                                svgArena.alloc("polygon");
                                            svgPoly.setAttribute(
                                                "shape-rendering",
                                                "crispEdges",
                                            );
                                            svgPoly.setAttribute(
                                                "points",
                                                `${ax} ${ay} ${bx} ${by} ${cx} ${cy}`,
                                            );
                                            svgPoly.setAttribute(
                                                "fill",
                                                `rgba(${colorR * 255},${colorG * 255}, ${colorB * 255}, ${colorA})`,
                                            );
                                            svgFragment.appendChild(svgPoly);
                                        }
                                        break;
                                    default: {
                                    }
                                }
                            }

                            handmadeSvgInner.appendChild(svgFragment);
                        } else if (handmadeSvgInner.childElementCount) {
                            handmadeSvg.replaceChild(
                                handmadeSvgInner.cloneNode(false),
                                handmadeSvgInner,
                            );
                        }
                    }
                    lastDrawTime = now;
                    requestAnimationFrame(draw);
                }
                requestAnimationFrame(draw);
            </script>
            <style>
                body {
                    accent-color: deeppink;
                    font-family: monospace;
                    margin: 0;
                    user-select: none;
                }
                header {
                    display: flex;
                    gap: 1ex;
                    flex-direction: column;
                    color: #fff;
                    background-color: #333a;
                    padding: 1em;
                    grid-column: 1 / -1;
                }
                header > p {
                    margin: 0;
                }
                h1 > img {
                    width: 1em;
                    height: 1em;
                    vertical-align: middle;
                    margin: 0;
                }
                a {
                    c
                }
                h1 {
                    grid-column: 1 / -1;
                    grid-row: 1 / span 1;
                    margin: 0;
                    display: flex;
                    gap: 0.75ex;
                    align-items: center;
                }
                h2 {
                    margin: 0;
                }
                .app {
                    padding: 2em;
                    display: flex;
                    flex-direction: column;
                    gap: 1em;
                }
                .grid {
                    position: absolute;
                    top: 0;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    gap: 1em;
                    display: grid;
                    padding: 1em;
                    grid-template-columns: 1fr 1fr;
                    grid-auto-flow: column;
                    grid-template-rows: auto 1fr;
                    gap: 1em;
                    justify-content: space-between;
                    align-items: start;
                    pointer-events: none;
                }
                .grid > * {
                    pointer-events: all;
                }
                .loading {
                    opacity: 0.1;
                }
                section {
                    display: flex;
                    flex-direction: column;
                    justify-content: stretch;
                    flex-grow: 1;
                }
                pre {
                    background-color: #111a;
                    color: #fff;
                    padding: 1em;
                    margin: 0;
                    flex-grow: 1;
                }
                canvas {
                    background-color: lemonchiffon;
                }
                summary {
                    padding: 1em;
                    cursor: pointer;
                    background-color: #eee;
                    user-select: none;
                }
                .scroller {
                    max-height: 30vh;
                    overflow: auto;
                }
                label {
                    display: flex;
                    align-items: center;
                    gap: 1ex;
                    justify-content: start;
                    justify-self:start;
                    background-color: #333a;
                    color: #fff;
                    padding: 0.5ex 1.5em 0.5ex 1.5ex;
                    user-select: none;
                }
                label:has([type="range"]) {
                    flex-grow: 1;
                }
                button {
                    background-color: #111;
                    color: #fff;
                    border: none;
                    border-radius: 4px;
                    padding: 1ex;
                    font: inherit;
                    cursor: pointer;
                }
                button:hover {
                    background-color: #333;
                }

                button:active {
                    background-color: #000;
                    color: #eee;
                }
                input[type="range"] {
                    margin: 0;
                    flex-grow: 1;
                    padding: 1.5ex 0;
                }

                input[type="checkbox"] {
                    height: 2em;
                }
                fieldset {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 1ex;
                    padding: 0;
                    margin: 0 0 1ex;
                    border: none;
                    justify-self: end;
                }
                .controls {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 1em;
                    justify-content: start;
                    flex-grow: 1;
                }
                canvas {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    width: 100%;
                    height: 100%;
                    z-index: -2;
                    touch-action: none;
                }
                .panel{
                    align-self: end;
                }
                .log h2 {
                    background-color: #111;
                    color: #fff;
                    font-size: 1em;
                    padding: 1ex;
                }
                summary {
                    background-color: #111;
                    color: #fff;
                }

                details > div {
                   padding: 1em;
                   background-color: #f0f0f0;
                }
                kbd {
                    background-color: #ddd;
                    border: 1px solid #ccc;
                    color: #000;
                    border-radius: 3px;
                    padding: 2px 4px;
                    display: inline-block;
                }
                a {
                    color: inherit;
                }
                .stick {
                    display: block;
                    position: fixed;
                    width: 200px;
                    height: 200px;
                    bottom: 0;
                    right: 0;
                    cursor: move;
                    opacity: 0.5;
                    touch-action: none;
                }
                .stick:hover {
                    opacity: 1;
                }

                .svg-render {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    width: 100%;
                    height: 100%;
                    z-index: -1;
                    pointer-events: none;
                }
            </style>
        </div>
    </body>
</html>
