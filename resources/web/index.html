<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <link rel="icon" href="favicon.svg" />
        <title>Handmade Hero</title>
    </head>
    <body>
        <canvas id="handmadeCanvas" width="800" height="600"></canvas>
        <svg id="handmadeStick" viewBox="-150 -150 300 300" class="stick">
            <circle cx="0" cy="0" r="100" fill="#1115"></circle>
            <circle
                id="handmadeStickNob"
                cx="0"
                cy="0"
                r="50"
                fill="#111a"
            ></circle>
        </svg>
        <svg id="handmadeSvg" viewBox="-150 -150 300 300" class="svg-render">
            <g id="handmadeSvgInner"></g>
        </svg>
        <div class="app">
            <div class="grid" id="handmadeGrid">
                <header>
                    <h1>
                        <img src="favicon.svg" alt="Icon" />
                        Handmade Hero
                    </h1>
                    <p>
                        Web Version of an
                        <a
                            href="https://guide.handmadehero.org/"
                            target="_blank"
                            >Handmade Hero Style Game</a
                        >
                    </p>
                </header>

                <fieldset>
                    <div class="controls">
                        <label>
                            <input
                                type="checkbox"
                                id="handmadeMute"
                                checked="checked"
                            />
                            Muted
                        </label>
                        <label>
                            Volume:
                            <input
                                type="range"
                                min="0"
                                max="1"
                                step="0.01"
                                id="handmadeVolume"
                                value="0.1"
                            />
                        </label>
                    </div>
                </fieldset>
                <section class="log">
                    <h2>Log</h2>
                    <pre id="handmadeLog"></pre>

                    <details>
                        <summary>About</summary>
                        <div>
                            <p>
                                Press <kbd>Right Arrow</kbd> to spawn a new
                                player.
                            </p>
                            <p>
                                Press <kbd>W</kbd>, <kbd>A</kbd>, <kbd>S</kbd>,
                                <kbd>D</kbd> to move around.
                            </p>
                            <p>
                                Press <kbd>Backspace</kbd> to build a wall or
                                use the left and right mouse buttons to
                                draw/erase walls.
                            </p>
                            <p>
                                Press middle mouse button to pan the camera. Use
                                the scrollwheel to pan the camera up and down or
                                hold <kbd>spacebar </kbd> while scrolling to
                                zoom in and out.
                            </p>
                        </div>
                    </details>
                </section>
            </div>

            <script type="module">
                function log(...args) {
                    if (handmadeLog.childNodes.length > 2) {
                        handmadeLog.removeChild(handmadeLog.firstChild);
                    }
                    handmadeLog.appendChild(
                        document.createTextNode(args.join(", ") + "\n"),
                    );
                }
                const memory = new WebAssembly.Memory({
                    initial: 32,
                    maximum: 32,
                    shared: true,
                });

                const wasm = await WebAssembly.compileStreaming(
                    fetch("handmade.wasm"),
                );
                const instance = await WebAssembly.instantiate(wasm, {
                    env: {
                        memory,
                    },
                });

                const blockSize = 128;
                handmadeMute.checked = true;

                const renderBase = instance.exports.get_render_list();
                const audioCtxLazy = (() => {
                    let prom = null;
                    return () => {
                        if (!prom) {
                            prom = new Promise(async (res) => {
                                const ctx = new AudioContext({
                                    samplingRate: 44100,
                                });
                                await ctx.audioWorklet.addModule("worklet.js");

                                const bufferNode = new AudioWorkletNode(
                                    ctx,
                                    "wasm-processor",
                                    {
                                        processorOptions: { memory, wasm },
                                    },
                                );
                                const volume = ctx.createGain();
                                const gain = ctx.createGain();
                                gain.gain.value = handmadeMute.checked ? 0 : 1;
                                instance.exports.setup();

                                volume.gain.value =
                                    handmadeVolume.valueAsNumber;
                                bufferNode.connect(volume);
                                volume.connect(gain);
                                gain.connect(ctx.destination);

                                res({ audioCtx: ctx, gain, volume });
                            });
                        }

                        return prom;
                    };
                })();
                handmadeMute.addEventListener("input", async (evt) => {
                    const target = evt.currentTarget;
                    const { audioCtx, gain, volume } = await audioCtxLazy();
                    if (audioCtx.state !== "running") {
                        gain.gain.value = 0;
                    }
                    await audioCtx.resume();
                    const now = audioCtx.currentTime;
                    const fadeTime = 0.1;
                    handmadeGrid.classList.remove("loading");
                    gain.gain.cancelScheduledValues(now);
                    gain.gain.setValueAtTime(gain.gain.value, now);
                    gain.gain.linearRampToValueAtTime(
                        target.checked ? 0 : 1,
                        audioCtx.currentTime + fadeTime,
                    );
                });
                handmadeVolume.addEventListener("input", async (evt) => {
                    const { audioCtx, gain, volume } = await audioCtxLazy();
                    const target = evt.currentTarget;
                    await audioCtx.resume();
                    const now = audioCtx.currentTime;
                    const fadeTime = 0.1;
                    handmadeGrid.classList.remove("loading");
                    volume.gain.cancelScheduledValues(now);
                    volume.gain.setValueAtTime(gain.gain.value, now);
                    volume.gain.linearRampToValueAtTime(
                        target.valueAsNumber,
                        audioCtx.currentTime + fadeTime,
                    );
                });

                function resize() {
                    handmadeCanvas.width =
                        window.devicePixelRatio * handmadeCanvas.clientWidth;
                    handmadeCanvas.height =
                        window.devicePixelRatio * handmadeCanvas.clientHeight;
                    instance.exports.resize_viewport(
                        handmadeCanvas.width,
                        handmadeCanvas.height,
                    );
                    log("resize", handmadeCanvas.width, handmadeCanvas.height);
                }
                window.addEventListener("resize", resize);
                resize();

                handmadeCanvas.addEventListener("pointerenter", () => {
                    instance.exports.toggle_mouse(true);
                    log("enter");
                });

                handmadeCanvas.addEventListener("contextmenu", (evt) => {
                    evt.preventDefault();
                });

                handmadeCanvas.addEventListener("pointermove", (evt) => {
                    const rect = evt.currentTarget.getBoundingClientRect();
                    instance.exports.toggle_mouse(true);
                    instance.exports.mouse_move(
                        evt.clientX - rect.left,
                        evt.clientY - rect.top,
                    );
                });
                handmadeCanvas.addEventListener("pointerdown", async (evt) => {
                    const target = evt.currentTarget;
                    const { audioCtx, gain, volume } = await audioCtxLazy();
                    await audioCtx.resume();
                    target.setPointerCapture(evt.pointerId);
                    instance.exports.mouse_button_press(evt.button);
                });
                handmadeCanvas.addEventListener("pointerup", (evt) => {
                    instance.exports.mouse_button_release(evt.button);
                });
                handmadeCanvas.addEventListener("pointerleave", () => {
                    instance.exports.toggle_mouse(false);

                    log("leave");
                });
                handmadeStick.addEventListener("pointerdown", (evt) => {
                    if (evt.isPrimary) {
                        evt.currentTarget.setPointerCapture(evt.pointerId);
                        moveStick(evt);
                    }
                });

                const stickPoint = handmadeStick.createSVGPoint();
                function moveStick(evt) {
                    stickPoint.x = evt.clientX;
                    stickPoint.y = evt.clientY;
                    var svgGlobal = stickPoint.matrixTransform(
                        handmadeStick.getScreenCTM().inverse(),
                    );
                    const angle = Math.atan2(svgGlobal.y, svgGlobal.x);
                    const mag = Math.min(
                        Math.hypot(svgGlobal.y, svgGlobal.x),
                        100,
                    );
                    handmadeStickNob.setAttribute(
                        "transform",
                        `translate(${Math.cos(angle) * mag},${Math.sin(angle) * mag})`,
                    );
                    instance.exports.controller_stick(
                        0,
                        (Math.cos(angle) * mag) / 100,
                        -(Math.sin(angle) * mag) / 100,
                    );
                }
                handmadeStick.addEventListener("pointermove", (evt) => {
                    if (evt.currentTarget.hasPointerCapture(evt.pointerId)) {
                        moveStick(evt);
                    }
                });
                handmadeStick.addEventListener("pointerup", (evt) => {
                    if (evt.currentTarget.hasPointerCapture(evt.pointerId)) {
                        handmadeStickNob.setAttribute(
                            "transform",
                            "translate(0,0)",
                        );

                        instance.exports.controller_stick(0, 0, 0);
                    }
                });
                handmadeStick.addEventListener("lostpointercapture", (evt) => {
                    if (evt.isPrimary) {
                        handmadeStickNob.setAttribute(
                            "transform",
                            "translate(0,0)",
                        );

                        instance.exports.controller_stick(0, 0, 0);
                    }
                });

                const buttons = {
                    MoveUp: 0,
                    MoveDown: 1,
                    MoveLeft: 2,
                    MoveRight: 3,
                    ActionUp: 4,
                    ActionDown: 5,
                    ActionLeft: 6,
                    ActionRight: 7,
                    LeftShoulder: 8,
                    RightShoulder: 9,
                    Menu: 10,
                    Back: 11,
                };
                const keymap = {
                    " ": "Menu",
                    Backspace: "Back",
                    w: "MoveUp",
                    s: "MoveDown",
                    a: "MoveLeft",
                    d: "MoveRight",
                    ArrowUp: "ActionUp",
                    ArrowLeft: "ActionLeft",
                    ArrowRight: "ActionRight",
                    ArrowDown: "ActionDown",
                };
                window.addEventListener("keydown", async (evt) => {
                    if (keymap[evt.key]) {
                        evt.preventDefault();

                        instance.exports.controller_button_press(
                            0,
                            buttons[keymap[evt.key]],
                        );
                    }
                });

                window.addEventListener("keyup", (evt) => {
                    if (keymap[evt.key]) {
                        evt.preventDefault();
                        instance.exports.controller_button_release(
                            0,
                            buttons[keymap[evt.key]],
                        );
                    }
                });

                window.addEventListener("blur", (evt) => {
                    instance.exports.blur();
                });

                handmadeCanvas.addEventListener("wheel", (evt) => {
                    evt.preventDefault();
                    instance.exports.scroll_wheel(
                        evt.deltaX / 4,
                        evt.deltaY / 4,
                    );
                });
                const drawCtx = handmadeCanvas.getContext("2d");
                drawCtx.fillStyle = "#fed";
                drawCtx.fillRect(
                    0,
                    0,
                    handmadeCanvas.width,
                    handmadeCanvas.height,
                );
                let lastDrawTime = 0;
                const svgArena = (() => {
                    let index = {
                        rect: 0,
                        polygon: 0,
                    };
                    let allocated = {
                        rect: [],
                        polygon: [],
                    };
                    return {
                        reset: () => {
                            log("svg arena" + allocated["rect"].length);
                            index["rect"] = 0;
                            index["polygon"] = 0;
                        },
                        alloc: (type) => {
                            if (index[type] >= allocated[type].length) {
                                allocated[type].push(
                                    document.createElementNS(
                                        "http://www.w3.org/2000/svg",
                                        type,
                                    ),
                                );
                            }
                            return allocated[type][index[type]++];
                        },
                    };
                })();
                const svgFragment = document.createDocumentFragment();
                function draw(now) {
                    drawCtx.fillStyle = "#fed";
                    const render_list_size = instance.exports.update_and_render(
                        (lastDrawTime ? now - lastDrawTime : 0) / 1000,
                    );

                    log("render size: " + render_list_size);
                    const render_commands = new Float32Array(
                        memory.buffer,
                        renderBase,
                        render_list_size * 11,
                    );
                    const render_commands_int = new Int32Array(
                        memory.buffer,
                        renderBase,
                        render_list_size * 11,
                    );
                    drawCtx.fillStyle = "#fed";
                    drawCtx.fillRect(
                        0,
                        0,
                        handmadeCanvas.width,
                        handmadeCanvas.height,
                    );
                    //  drawCtx.save();
                    //  drawCtx.translate(
                    //      +handmadeCanvas.width / 2,
                    //      +handmadeCanvas.height / 2,
                    //  );
                    //  drawCtx.scale(0.4, 0.4);
                    //  drawCtx.translate(
                    //      -handmadeCanvas.width / 2,
                    //      -handmadeCanvas.height / 2,
                    //  );

                    for (let r = 0; r < render_commands.length; r += 11) {
                        const type = render_commands_int[r + 0];
                        switch (type) {
                            case 0:
                                {
                                    const minX = render_commands[r + 1];
                                    const minY = render_commands[r + 2];
                                    const maxX = render_commands[r + 3];
                                    const maxY = render_commands[r + 4];
                                    const colorR = render_commands[r + 5];
                                    const colorG = render_commands[r + 6];
                                    const colorB = render_commands[r + 7];
                                    const colorA = render_commands[r + 8];
                                    drawCtx.fillStyle = `rgba(${colorR * 255},${colorG * 255}, ${colorB * 255}, ${colorA})`;
                                    drawCtx.fillRect(
                                        Math.min(maxX, minX),
                                        Math.min(maxY, minY),
                                        Math.abs(maxX - minX),
                                        Math.abs(maxY - minY),
                                    );
                                }
                                break;

                            case 1:
                                {
                                    const ax = render_commands[r + 1];
                                    const ay = render_commands[r + 2];
                                    const bx = render_commands[r + 3];
                                    const by = render_commands[r + 4];
                                    const cx = render_commands[r + 5];
                                    const cy = render_commands[r + 6];
                                    const colorR = render_commands[r + 7];
                                    const colorG = render_commands[r + 8];
                                    const colorB = render_commands[r + 9];
                                    const colorA = render_commands[r + 10];
                                    drawCtx.fillStyle = `rgba(${colorR * 255},${colorG * 255}, ${colorB * 255}, ${colorA})`;
                                    drawCtx.beginPath();
                                    drawCtx.moveTo(ax, ay);
                                    drawCtx.lineTo(bx, by);
                                    drawCtx.lineTo(cx, cy);
                                    drawCtx.closePath();
                                    drawCtx.fill();
                                }
                                break;
                            default: {
                            }
                        }
                    }
                    drawCtx.restore();
                    {
                        handmadeSvg.setAttribute(
                            "viewBox",
                            `0 0 ${handmadeCanvas.width} ${handmadeCanvas.height}`,
                        );
                        svgArena.reset();
                        handmadeSvg.replaceChild(
                            handmadeSvgInner.cloneNode(false),
                            handmadeSvgInner,
                        );
                        for (let r = 0; r < render_commands.length; r += 11) {
                            const type = render_commands_int[r + 0];
                            switch (type) {
                                case 0:
                                    {
                                        const svgRect = svgArena.alloc("rect");
                                        const minX = render_commands[r + 1];
                                        const minY = render_commands[r + 2];
                                        const maxX = render_commands[r + 3];
                                        const maxY = render_commands[r + 4];
                                        const colorR = render_commands[r + 5];
                                        const colorG = render_commands[r + 6];
                                        const colorB = render_commands[r + 7];
                                        const colorA = render_commands[r + 8];

                                        svgRect.setAttribute(
                                            "x",
                                            Math.min(maxX, minX),
                                        );
                                        svgRect.setAttribute(
                                            "y",
                                            Math.min(maxY, minY),
                                        );
                                        svgRect.setAttribute(
                                            "width",
                                            Math.abs(maxX - minX),
                                        );
                                        svgRect.setAttribute(
                                            "height",
                                            Math.abs(maxY - minY),
                                        );
                                        svgRect.setAttribute(
                                            "fill",
                                            `rgba(${colorR * 255},${colorG * 255}, ${colorB * 255}, ${colorA})`,
                                        );
                                        svgFragment.appendChild(svgRect);
                                    }
                                    break;

                                case 1:
                                    {
                                        const ax = render_commands[r + 1];
                                        const ay = render_commands[r + 2];
                                        const bx = render_commands[r + 3];
                                        const by = render_commands[r + 4];
                                        const cx = render_commands[r + 5];
                                        const cy = render_commands[r + 6];
                                        const colorR = render_commands[r + 7];
                                        const colorG = render_commands[r + 8];
                                        const colorB = render_commands[r + 9];
                                        const colorA = render_commands[r + 10];

                                        const svgPoly =
                                            svgArena.alloc("polygon");

                                        svgPoly.setAttribute(
                                            "points",
                                            `${ax} ${ay} ${bx} ${by} ${cx} ${cy}`,
                                        );
                                        svgPoly.setAttribute(
                                            "fill",
                                            `rgba(${colorR * 255},${colorG * 255}, ${colorB * 255}, ${colorA})`,
                                        );
                                        svgFragment.appendChild(svgPoly);
                                    }
                                    break;
                                default: {
                                }
                            }
                        }

                        handmadeSvgInner.appendChild(svgFragment);
                    }
                    lastDrawTime = now;
                    requestAnimationFrame(draw);
                }
                requestAnimationFrame(draw);
            </script>
            <style>
                body {
                    font-family: monospace;
                    margin: 0;
                }
                header {
                    display: flex;
                    gap: 1ex;
                    flex-direction: column;
                    color: #fff;
                }
                header > p {
                    margin: 0;
                }
                h1 > img {
                    width: 1em;
                    height: 1em;
                    vertical-align: middle;
                    margin: 0;
                }
                a {
                    c
                }
                h1 {
                    grid-column: 1 / -1;
                    grid-row: 1 / span 1;
                    margin: 0;
                    display: flex;
                    gap: 0.75ex;
                    align-items: center;
                }
                h2 {
                    margin: 0;
                }
                .app {
                    padding: 2em;
                    display: flex;
                    flex-direction: column;
                    gap: 1em;
                }
                .grid {
                    position: absolute;
                    top: 0;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    display: grid;
                    padding: 2em;
                    grid-template-columns: 1fr 1fr;
                    grid-template-rows: auto 1fr;
                    gap: 1em;
                    justify-content: space-between;
                    align-items: start;
                    pointer-events: none;
                }
                .grid > * {
                    pointer-events: all;
                }
                .loading {
                    opacity: 0.1;
                }
                section {
                    display: flex;
                    flex-direction: column;
                    justify-content: stretch;
                    flex-grow: 1;
                }
                pre {
                    background-color: #111a;
                    color: #fff;
                    padding: 1em;
                    margin: 0;
                    flex-grow: 1;
                }
                canvas {
                    background-color: lemonchiffon;
                }
                summary {
                    padding: 1em;
                    cursor: pointer;
                    background-color: #eee;
                    user-select: none;
                }
                .scroller {
                    max-height: 30vh;
                    overflow: auto;
                }
                label {
                    display: flex;
                    align-items: center;
                    gap: 1ex;
                    justify-content: end;
                    justify-self: end;
                    background-color: #333a;
                    color: #fff;
                    padding: 0 1em 0 1ex;
                    user-select: none;
                }
                button {
                    background-color: #111;
                    color: #fff;
                    border: none;
                    border-radius: 4px;
                    padding: 1ex;
                    font: inherit;
                    cursor: pointer;
                }
                button:hover {
                    background-color: #333;
                }

                button:active {
                    background-color: #000;
                    color: #eee;
                }
                input[type="range"] {
                    padding: 1ex 0;
                    margin: 0;
                }
                fieldset {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 1ex;
                    padding: 0;
                    border: none;
                    justify-self: end;
                }
                .controls {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 1em;
                    justify-content: end;
                }
                canvas {
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    width: 100%;
                    height: 100%;
                    z-index: -2;
                }
                .log {
                    align-self: end;
                }
                details {
                    background-color: #f0f0f0;
                }

                details > div {
                    margin: 1em;
                }
                kbd {
                    background-color: #111;
                    color: #fff;
                    border-radius: 3px;
                    padding: 2px;
                    display: inline-block;
                }
                a {
                    color: inherit;
                }
                .stick {
                    display: block;
                    position: absolute;
                    width: 300px;
                    height: 300px;
                    bottom: 0;
                    right: 0;
                    cursor: move;
                    opacity: 0.5;
                }
                .stick:hover, .stick:active {
                    opacity: 1;
                }

                .svg-render {
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    width: 100%;
                    height: 100%;
                    z-index: -1;
                    pointer-events: none;
                }
            </style>
        </div>
    </body>
</html>
